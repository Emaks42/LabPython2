# Лабораторная работа 2
### Вариант Medium (пока без undo и history)
### Выполнил Максимов Егор М8О-103БВ-25

## Введение
В рамках этой лабораторной работы написано подобие командной оболочки bash, доступны команды ls, cd, cp, rm, cat, zip,
unzip, tar, untar, grep.


## Структура проекта

 <pre>
    .
    ├── LabPython2             # Кодовая база лабораторной работы
    │   ├── src/                               # Исходный код
    │   ├── tests/                             # Unit тесты
    │   ├── uv.lock                            # зависимости проекта
    │   ├── .gitignore                         # git ignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание проекта, с описанием файлов и с титульником о том,
                                               # что и какая задача
</pre>

В папке [src](./src) лежат файлы с реализацией задачи заданной в лабораторной работе. Осонвным файлом является файл
[main.py](./src/main.py) в котором описана точка входа в приложение - функция **main**. Также в этой папке лежат файлы
[bash_processor.py](./src/bash_processor.py), [preprocessor.py](./src/preprocessor.py), папка [commands](./src/commands) и
файл [constants.py](./src/constants.py), в первом файле лежит основной класс работы - обработчик команд bash (по сути
командная оболочка), во втором - предобработчик команд (команды вводятся с клавиатуры), в папке лежит код почти всех команд
(команды cd и mv лежат в основном классе, так как они слишком малы), в последнем файле лежат константы для работы с командами



В папке [tests](./tests) лежат **unit** тесты для проверки функциональности программы и её частей.
Используется библиотека pytest и pyfakefs (также есть временные директории). В файлах вида **команда_test** лежат тесты к
соответствующим командам, в файле [preprocessing_and_processor_test.py](./tests/preprocessing_and_processor_test.py) лежат
несколько тестов к препроцессору и классу BashProcessor (предполагается, что большую часть их функций проверятся во время
тестирования команд, туда вынесены особые случаи)

Также в папке [src](./src) находится файл [shell.log](./src/shell.log), в котором хранятся логи от работы BashProcessor'a

В качестве пакетного менджера в данном репозитории используется [uv](https://github.com/astral-sh/uv).

## Допущения
По большей части допущения соответствуют допущениям оригинального bash на Ububtu, но есть несколько моментов:
<ul>
<li>Если передать команде cat 0 аргументов, то это будет ошибка</li>
<li>Если передать команде ls файл, то это будет ошибка</li>
<li>В командах grep, zip, unzip, tar, untar предполагается фиксированное число аргументов</li>
<li>В командах cp и mv предполагается явное указкние нового имени директории/файла</li>
</ul>

## Алгоритм решения
Сначала будет описана общая работа класса BashProcessor, потом будут подробнее описаны команды и препроцессор
**По умолчанию BashProcessor в main запускается в домашней директории, изменить это можно в [constants.py](./src/constants.py)
(BASE_DIR_FOR_MAIN)**
<ol>
<li>Пользователь вводит команду или exit для завершения работы программы</li>
<li>Полученная команда передаётся в класс BashProcessor (через функцию command)</li>
<li>Команда обрабатывается препроцессором</li>
<li>В зависимости от команды выполняется соответствующая ей функция (записаны в поле available_commands класса)</li>
<li>Происхоит логирование команды и успешности её выполнения (единственное логирование во всём коде)</li>
<li>Результат работы команды выводится пользователю</li>
</ol>

### Работа препроцессора
<ol>
<li>Производится очистка от лишних пробелов (с помощью модуля re любое количество пробелов замещается на 1)</li>
<li>Создаются вспомогательные переменные:
<ul>
<li>buffer - переменная, хранящая в себе определённую последовательность символов (по сути текст между двумя пробелами
или в кавычках или с экранированым пробелом)</li>
<li>quoted - переменная, хранящая наличие и тип кавычек</li>
<li>screened - переменная, отвечающая за экранирование символов</li>
<li>buffer_data_type - переменная, хранящая в себе тип данных в буфере (могут быть OPTION, PATH, TEXT, изначально OPTION)</li>
<li>text_arg_required - переменная, хранящая количество требуемых текстовых аргументов команды</li>
<li>current_index - переменнная, хранящая текущий индекс в строке</li>
</ul></li>
<li>Производится линейный проход по строке по следующей схеме:
<ol>
<li>Если встречен пробел и нет экранирования и кавычек то доопределяем тип хранимого в буфере, сохраняем токен в итоговый список токенов и очищаем buffer</li>
<li>Если встречаем кавычку, то поверяем экранирование и наличие кавычек до, в зависимости от этого или добавляем её в буфер, или
изменяем переменны, отвечающие за кавычки</li>
<li>Если встречаем обратный слеш, то изменяем зачение переменной screened</li>
<li>Если встречаем любой другой символ или если из-за экранирования и кавычек ничего выше не обработалось, сохраняем его в
буфер</li>
</ol>
</li>
<li>остатки данных в buffer обрабатываются аналогично 3</li>
<li>Выделяем конкретное название команды, проверяем её существоание</li>
<li>Обрабатываем токены:
<ul>
<li>Если это путь, то переводим его в абсолютный формат</li>
<li>Если это текст, то просто записываем его</li>
<li>Если это опция, то разделяем её на части (выражения вида -la -> -l -a), и проверяем наличие этой опции у команды</li>
</ul>
</li>
</ol>
Также в препроцессоре есть отдельная функция для обработки опций уже в команде (чтобы не переусложнять вывод осоновной функции)
Возвращет словать, где опции соответствует bool.

### Команды

Функции команд имеют общие черты:
<ul>
<li>Есть 2 потока - estream и ostream (по функционалу как в bash)</li>
<li>Принимают на вход неопределённое множество аргументов</li>
<li>Есть стандартные ошибки доступности, существования пути</li>
</ul>

### Особенности отдельных команд
<ul>
<li><b>ls:</b>
<ul>
<li>Есть опция -l, дополнительно выводит дату измения, размер и права доступа (обработка прав в отдельном файле)</li>
<li>Есть обработка пустого ввода (замена на текущую директорию)</li>
<li>Есть обработка названий с символами, для которых нужны кавычки (пробелы и т.п.), сдеано через константу</li>
<li>Есть проверка на ввод не директорий</li>
<li>Предусмотрен множественный ввод</li>
<li>Использует модуль os</li>
</ul>
</li>
<li><b>cd:</b>
<ul>
<li>Есть обработка пустого ввода (переход в домашнюю директорию)</li>
<li>Лежит в осоновном классе, так как работет с параметром класса BashProcessor</li>
<li>Есть проверка на ввод не директорий</li>
</ul>
</li>
<li><b>cp:</b>
<ul>
<li>Есть опция -r, для работы с директориями (и проверка её наличия при работе с ними)</li>
<li>Есть проверка количества аргументов</li>
<li>Есть обработка множественного ввода</li>
<li>Используются shutil и pathlib</li>
</ul>
</li>
<li><b>cat:</b>
<ul>
<li>Есть обработка пустого ввода (ошибка)</li>
<li>Есть обработка некорректного ввода</li>
<li>Есть проверка на ввод не файлов</li>
<li>Используется pathlib</li>
</ul>
</li>
<li><b>rm:</b>
<ul>
<li>Есть обработка пустого ввода (ошибка)</li>
<li>Есть опция -r для обработки директорий (и ошибки связанные с этим)</li>
<li>Есть проверка на попытки удалить родительские или корневые директории</li>
<li>Есть запрос пользователю об удалении директорий (и опция -f для его пропуска)</li>
<li>Используются модули shutil и pathlib</li>
</ul>
</li>
<li><b>mv:</b>
<ul>
<li>Является композицией rm и cp</li>
<li>Лежит в осоновном классе, так как слишком мала</li>
<li>Есть опция -r</li>
<li>Можно использовать для переименования файлов (ошибки с rm заглушены)</li>
</ul>
</li>
<li><b>zip. unzip, tar, untar:</b>
<ul>
<li>Имеют фиксированное число и тип аргументов</li>
<li>Крайне похожи между собой, по сути я вляются самыми прямыми реализациями функций из библиотек</li>
<li>Используются zipfile и tarfile</li>
</ul>
</li>
<li><b>grep:</b>
<ul>
<li>Есть опция -r, для работы с директориями (и проверка её наличия при работе с ними)</li>
<li>Есть проверка количества аргументов</li>
<li>Есть обязательный текстовый аргумент</li>
<li>Есть опция -i (переводит всё содержимое файлов в нижний регистр)</li>
<li>Есть рекурсия для работы с -r</li>
<li>Есть обработка нечитаемых файлов</li>
<li>Используются pathlib и re</li>
</ul>
</li>
</ul>

## Тестирование
Для тестирования используется модуль pytest, как вспологательный идёт pyfakefs, позволяющий создать виртуальную
файловую систему для тестов, но из-за конфликтов некоторых команд с ней иногда используется фикстура tmp_path из pytest,
создающая временную папку для тестов. Также используется фикстура monkeypatch и возможность pytest.mark.parametrize

### Конфигурационный файл ([conftest.py](./tests/conftest.py))

<pre>
import pytest
from src.bash_processor import BashProcessor
from pyfakefs.fake_filesystem import FakeFilesystem
import os.path
from os import chmod


@pytest.fixture
def bash_processor(fs: FakeFilesystem):
    fs.create_dir("data")
    for num in range(10):
        fs.create_file(os.path.join("data", f"{num}.txt"), contents=f"{num}")
    fs.create_dir(os.path.join("data", "ls_folder"))
    ls_fold_path = os.path.join("data", "ls_folder")
    for num in range(3):
        fs.create_file(os.path.join(ls_fold_path, f"{num}.txt"), contents=f"{num}")
    fs.create_dir(os.path.join("data", "permitted"))
    perm_dir = os.path.join("data", "permitted")
    fs.create_file(os.path.join(perm_dir, "secret"))
    chmod(perm_dir, 0)
    return BashProcessor("data")

</pre>

В этом файле создаётся основная фикстура для тестирования - BashProcessor, подключённый к виртуальной файловой системе
Сама система имееет следующую структуру:


 <pre>
    /
    ├── data              # основная папка
    │   ├── 0.txt         # файл с текстом 0
    │   ├── 1.txt         # файл с текстом 1
    │   ├──....
    │   ├── 9.txt         # файл с текстом 9
    │   ├── ls_folder/    # Папка, содержит файлы с ччислами от 0.txt до 2.txt
    │   ├── permitted     # Папка, к которой нет прав доступа,
                            содержит файл (secret) с такими же свойствами
</pre>

### Тестовые файлы

Тесты в каждом файле разделены по следующему принципу: сначала тесты базаовой работы команд и специальных возможностей
(если таковые есть), дальше идёт тестирование ошибок (test_команда_error...). Так как результатом работы функции command
класса BashProcessor является строка, то по ней удобно производить тесты (заодно проверяется работоспособность
препроцессора)

### Примеры тестов

Тест корректности работы команды cd

<pre>
def test_base_cd_work(bash_processor):
    assert bash_processor.command("cd ls_folder") == ""
    assert bash_processor.get_current_directory() == "/data/ls_folder"
</pre>

Тест корректности работы команды ls

<pre>
def test_base_ls_work(bash_processor):
    assert bash_processor.command("ls ls_folder") == '/data/ls_folder\n0.txt\n1.txt\n2.txt\n'
</pre>

Стандартная проверка на обработку несуществующей папки

<pre>
def test_rm_error_no_such_file(bash_processor):
    assert bash_processor.command("rm nonex") == "ERROR: no such file\n"
</pre>

Стандартная проверка на обработку отсутствия прав

<pre>
def test_ls_error_permission_denied(bash_processor):
    assert bash_processor.command("ls permitted") == "ERROR: permission denied\n"
</pre>

Работа с временной папкой

<pre>
def test_rm_dirs_f(tmp_path):
    bash_processor = BashProcessor(str(tmp_path))
    (tmp_path / "ls_folder").mkdir()
    assert bash_processor.command("rm -rf ls_folder") == ""
    assert bash_processor.command("ls") == ".\n\n"
</pre>

Использование monkeypatch для работы с вводом через input

<pre>
def absolute_input(s: str):
    if s[:28] == "Вы хотите удалить директорию":
        return "pass"
    else:
        return "y"


def test_rm_dirs(tmp_path, monkeypatch):
    bash_processor = BashProcessor(str(tmp_path))
    (tmp_path / "ls_folder").mkdir()
    monkeypatch.setattr('builtins.input', absolute_input)
    assert bash_processor.command("rm -r ls_folder") == ""
    assert bash_processor.command("ls") == ".\n\n"
</pre>

(в команде rm есть проверка на корректность ввода y/n)

Использование архива для создания нечитаемого cat файла

<pre>
def test_cat_error_incorrect_encoding(bash_processor):
    bash_processor.command("zip ls_folder ls_folder.zip")
    path = "/data/ls_folder.zip"
    assert bash_processor.command("cat ls_folder.zip") == f"ERROR: incorrect encoding of file {path}\n"
</pre>

Испльзование pytest.mark.parametrize в тесте для cat

<pre>
@pytest.mark.parametrize("command_,expected", [(f"cat {num}.txt", f"{num}\n") for num in range(10)])
def test_cat_base_work(bash_processor, command_, expected):
    assert bash_processor.command(command_) == expected
</pre>

Все тесты в сумме покрывают примерно 94% кода из src. Всего есть 86 тестов.
